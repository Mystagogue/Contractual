using System;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.Threading.Tasks;

namespace Contractual.WCF
{
    /// <summary>
    /// A generic, stand-alone replacement for any svcutil.exe generated "XXXClient". 
    /// </summary>
    /// <typeparam name="T">The service contract interface, whether generated by svcutil or taken directly from the service contract assembly</typeparam>
    public interface IClient<T> : IDisposable
    {
        ServiceEndpoint Endpoint { get; }
        ClientCredentials ClientCredentials { get; }
        IClientChannel InnerChannel { get; }

        /// <summary>
        /// Invoke service and leave cleanup, calling either "Dispose()" or "Close()", as the caller's responsibility.
        /// </summary>
        /// <typeparam name="TResult">The value returned from the service call</typeparam>
        /// <param name="invoke">Delegate that invokes the proxy.</param>
        /// <returns></returns>
        TResult Call<TResult>(Func<T, TResult> invoke);

        /// <summary>
        /// Invoke service and leave cleanup, calling either "Dispose()" or "Close()", as the caller's responsibility.
        /// </summary>
        /// <param name="invoke">Delegate that invokes the proxy.</param>
        void Call(Action<T> invoke);

        /// <summary>
        /// Used for async WCF proxy BeginXXX and EndXXX routines.  Either write your own ContinueWith(...) to Dispose of this client, 
        /// or use the Proxy&lt;T&gt;.Inovke(...) method instead.
        /// </summary>
        /// <typeparam name="TResult">The return type of the service call.</typeparam>
        /// <param name="invoke">A function that calls Task.Factory.FromAsync() or similar mechanism to produce an async WCF proxy invocation.</param>
        /// <returns>A Task to be followed by a "ContinueWith" operation (at least to close the proxy).</returns>
        Task<TResult> Invoke<TResult>(Func<T, Task<TResult>> invoke);

        /// <summary>
        /// Used for async WCF proxy BeginXXX and EndXXX routines.  Either write your own ContinueWith(...) to Dispose of this client, 
        /// or use the Proxy&lt;T&gt;.Inovke(...) method instead.
        /// </summary>
        /// <param name="invoke">A function that calls Task.Factory.FromAsync() or similar mechanism to produce an async WCF proxy invocation.</param>
        /// <returns>A Task to be followed by a "ContinueWith" operation (at least to close the proxy).</returns>
        Task Invoke(Func<T, Task> invoke);

        void Open();
        void Close();
        void Abort();
    }

    /// <summary>
    /// A generic, stand-alone replacement for any svcutil.exe generated "XXXClient".  It has a proper-functioning Dispose() method
    /// which corrects the bug usually associated with closing or disposing a WCF proxy.  Normally this should be created by the Proxy&lt;T&gt;.CreateClient()
    /// method, but technically it can be created directly.
    /// </summary>
    /// <typeparam name="T">The service contract interface, whether generated by svcutil or taken directly from the service contract assembly</typeparam>
    public class Client<T> : IClient<T> where T : class
    {
        protected InternalClient<T> innerClient;

        public virtual ServiceEndpoint Endpoint { get { return innerClient.Endpoint; } }
        public virtual ClientCredentials ClientCredentials { get { return innerClient.ClientCredentials; } }
        public virtual IClientChannel InnerChannel { get { return innerClient.InnerChannel; } }

        public Client()
        {
            innerClient = new InternalClient<T>();
        }

        public Client(string endpointConfigurationName)
        {
            innerClient = new InternalClient<T>(endpointConfigurationName);
        }

        /// <summary>
        /// Create a Proxy based on explicit endpoint information.  This constructor is primarily intended for self-hosted unit test scenarios.
        /// </summary>
        /// <param name="binding"></param>
        /// <param name="remoteAddress"></param>
        public Client(Binding binding, EndpointAddress remoteAddress)
        {
            innerClient = new InternalClient<T>(binding, remoteAddress);
        }

        /// <summary>
        /// Invoke service and leave cleanup, calling either "Dispose()" or "Close()", as the caller's responsibility.
        /// </summary>
        /// <typeparam name="TResult">The value returned from the service call</typeparam>
        /// <param name="invoke">Delegate that invokes the proxy.</param>
        /// <returns></returns>
        public virtual TResult Call<TResult>(Func<T, TResult> invoke)
        {
            TResult result = invoke(innerClient.Contract);
            return result;
        }

        /// <summary>
        /// Invoke service and leave cleanup, calling either "Dispose()" or "Close()", as the caller's responsibility.
        /// </summary>
        /// <param name="invoke">Delegate that invokes the proxy.</param>
        public virtual void Call(Action<T> invoke)
        {
            invoke(innerClient.Contract);
        }

        /// <summary>
        /// Used for async WCF proxy BeginXXX and EndXXX routines.  Either write your own ContinueWith(...) to Dispose of this client, 
        /// or use the Proxy&lt;T&gt;.Inovke(...) method instead.
        /// </summary>
        /// <typeparam name="TResult">The return type of the service call.</typeparam>
        /// <param name="invoke">A function that calls Task.Factory.FromAsync() or similar mechanism to produce an async WCF proxy invocation.</param>
        /// <returns>A Task to be followed by a "ContinueWith" operation (at least to close the proxy).</returns>
        public virtual Task<TResult> Invoke<TResult>(Func<T, Task<TResult>> invoke)
        {
            return invoke(innerClient.Contract);
        }

        /// <summary>
        /// Used for async WCF proxy BeginXXX and EndXXX routines.  Either write your own ContinueWith(...) to Dispose of this client, 
        /// or use the Proxy&lt;T&gt;.Inovke(...) method instead.
        /// </summary>
        /// <param name="invoke">A function that calls Task.Factory.FromAsync() or similar mechanism to produce an async WCF proxy invocation.</param>
        /// <returns>A Task to be followed by a "ContinueWith" operation (at least to close the proxy).</returns>
        public virtual Task Invoke(Func<T, Task> invoke)
        {
            return invoke(innerClient.Contract);
        }

        /// <summary>
        /// Calls CloseOrAbort();
        /// </summary>
        void System.IDisposable.Dispose()
        {
            Close();
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Call only if the channel is faulted.
        /// </summary>
        public virtual void Abort()
        {
            innerClient.Abort();
        }

        /// <summary>
        /// Safely handles the closing of a WCF proxy.
        /// </summary>
        public virtual void Close()
        {
            innerClient.CloseOrAbort();
        }

        /// <summary>
        /// Call to explicitly open the channel.
        /// </summary>
        public virtual void Open()
        {
            innerClient.Open();
        }

        public class InternalClient<TChannel> : ClientBase<TChannel> where TChannel : class
        {
            public InternalClient() { }

            public InternalClient(string endpointConfigurationName) :
                base(endpointConfigurationName)
            { }

            /// <summary>
            /// Create a Proxy based on explicit endpoint information.  This constructor is primarily intended for self-hosted unit test scenarios.
            /// </summary>
            /// <param name="binding"></param>
            /// <param name="remoteAddress"></param>
            public InternalClient(Binding binding, EndpointAddress remoteAddress) :
                base(binding, remoteAddress)
            { }

            public TChannel Contract
            {
                get { return base.Channel; }
            }
        }
    }

    /// <summary>
    /// Convenience implementation that helps to make stubbing proxies as easy as possible.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class FakeClient<T> : IClient<T> where T : class
    {
        protected T innerClient;
        protected ServiceEndpoint endpoint;
        protected ClientCredentials creds;
        protected IClientChannel channel;

        public virtual ServiceEndpoint Endpoint { get { return endpoint; } }
        public virtual ClientCredentials ClientCredentials { get { return creds; } }
        public virtual IClientChannel InnerChannel { get { return channel; } }

        public FakeClient(T inner, ServiceEndpoint endpoint = null, ClientCredentials creds = null, IClientChannel channel = null)
        {
            innerClient = inner;
        }

        /// <summary>
        /// Invoke service and leave cleanup, calling either "Dispose()" or "Close()", as the caller's responsibility.
        /// </summary>
        /// <typeparam name="TResult">The value returned from the service call</typeparam>
        /// <param name="invoke">Delegate that invokes the proxy.</param>
        /// <returns></returns>
        public virtual TResult Call<TResult>(Func<T, TResult> invoke)
        {
            TResult result = invoke(innerClient);
            return result;
        }

        /// <summary>
        /// Invoke service and leave cleanup, calling either "Dispose()" or "Close()", as the caller's responsibility.
        /// </summary>
        /// <param name="invoke">Delegate that invokes the proxy.</param>
        public virtual void Call(Action<T> invoke)
        {
            invoke(innerClient);
        }

        /// <summary>
        /// Used for async WCF proxy BeginXXX and EndXXX routines.  Either write your own ContinueWith(...) to Dispose of this client, 
        /// or use the Proxy&lt;T&gt;.Inovke(...) method instead.
        /// </summary>
        /// <typeparam name="TResult">The return type of the service call.</typeparam>
        /// <param name="invoke">A function that calls Task.Factory.FromAsync() or similar mechanism to produce an async WCF proxy invocation.</param>
        /// <returns>A Task to be followed by a "ContinueWith" operation (at least to close the proxy).</returns>
        public virtual Task<TResult> Invoke<TResult>(Func<T, Task<TResult>> invoke)
        {
            return invoke(innerClient);
        }

        /// <summary>
        /// Used for async WCF proxy BeginXXX and EndXXX routines.  Either write your own ContinueWith(...) to Dispose of this client, 
        /// or use the Proxy&lt;T&gt;.Inovke(...) method instead.
        /// </summary>
        /// <param name="invoke">A function that calls Task.Factory.FromAsync() or similar mechanism to produce an async WCF proxy invocation.</param>
        /// <returns>A Task to be followed by a "ContinueWith" operation (at least to close the proxy).</returns>
        public virtual Task Invoke(Func<T, Task> invoke)
        {
            return invoke(innerClient);
        }

        /// <summary>
        /// Calls CloseOrAbort();
        /// </summary>
        void System.IDisposable.Dispose()
        {
        }

        /// <summary>
        /// This is a NOP.
        /// </summary>
        public virtual void Abort()
        {
        }

        /// <summary>
        /// This is a NOP.
        /// </summary>
        public virtual void Close()
        {
        }

        /// <summary>
        /// This is a NOP.
        /// </summary>
        public virtual void Open()
        {
        }

    }
}
